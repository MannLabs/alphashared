name: Create Draft Release

on:
  workflow_call:
    inputs:
      package_name:
        description: 'Name of package, e.g. "alphadia", "peptdeep", ..'
        type: string
        required: true
      commit_to_release:
        description: 'Enter commit hash to release (example: ef4037cb571f99cb4919b520fde7174972aae473)'
        type: string
        required: true
      tag_to_release:
        description: 'Enter tag of the new release to create (example: v1.5.5). The code version needs to be bumped already to match the tag.'
        type: string
        required: true
      # optional switches
      build_nodejs_ui:
        description: 'Whether or not a nodejs UI needs to be built'
        type: boolean
        default: false
      test_app:
        description: 'Whether or not it should be tested that the executable is valid'
        type: boolean
        default: false
      python_version:
        description: "Python version to be used"
        type: string
        default: "3.11"

jobs:
  Get_New_Version:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.check_release_tag.outputs.new_version }}
      run_linux: ${{ steps.check_os.outputs.run_linux }}
      run_macos: ${{ steps.check_os.outputs.run_macos }}
      run_windows: ${{ steps.check_os.outputs.run_windows }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.commit_to_release }}
          fetch-depth: 0  # required to be able to check for existing tags

      - name: Check release tag
        id: check_release_tag
        shell: bash -le {0}
        run: |
          TAG_TO_RELEASE=${{ inputs.tag_to_release }}
          firstletter=${TAG_TO_RELEASE:0:1}
          if [ "$firstletter" != "v" ]; then
            echo "Tag ${TAG_TO_RELEASE} does not start with 'v'. Example: 'v1.2.3'."
            exit 1
          fi
          
          CURRENT_VERSION=$(grep "__version__" ${{ inputs.package_name }}/__init__.py | cut -f3 -d ' ' | sed 's/"//g')
          if [ "v${CURRENT_VERSION}" != "${TAG_TO_RELEASE}" ]; then
            echo Code version "v${CURRENT_VERSION}" does not match the tag to release ${TAG_TO_RELEASE}

          fi
          echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
      # exit 1  #TODO add again

      - name: Check if tag already exists
        run: |
          TAG="${{ inputs.tag_to_release }}"
          if git show-ref --tags --verify --quiet "refs/tags/${TAG}"; then
            echo "Tag ${TAG} exists"
            exit 1
          fi

      - name: Check supported OS
        id: check_os
        run: |
          if [[ -d 'release/macos' ]]; then
            echo "run_macos=true" >> $GITHUB_OUTPUT
          else
            echo "run_macos=false" >> $GITHUB_OUTPUT
          fi
          if [[ -d 'release/linux' ]]; then
            echo "run_linux=true" >> $GITHUB_OUTPUT
          else
            echo "run_linux=false" >> $GITHUB_OUTPUT
          fi
          if [[ -d 'release/windows' ]]; then
            echo "run_windows=true" >> $GITHUB_OUTPUT
          else
            echo "run_windows=false" >> $GITHUB_OUTPUT
          fi

  Create_Draft_Release:
    runs-on: ubuntu-latest
    needs: Get_New_Version
    steps:
      - name: Draft Release
        id: draft_release
        uses: softprops/action-gh-release@v2
        continue-on-error: true
        with:
          name: ${{ inputs.tag_to_release }}
          tag_name: ${{ inputs.tag_to_release }}
          target_commitish: ${{ inputs.commit_to_release }}
          draft: True

      # for some reason, the above step failes for peptdeep
      - name: Draft Release (alternative)
        if: ${{ steps.draft_release.conclusion == 'failure' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/releases \
            -f "tag_name=${{ inputs.tag_to_release }}" \
            -f "name=${{ inputs.tag_to_release }}" \ 
            -f "target_commitish=${{ inputs.commit_to_release }}" \ 
            -F "draft=true"

  Create_Linux_Installer:
    needs: [ Create_Draft_Release, Get_New_Version ]
    if: ${{ needs.Get_New_Version.outputs.run_linux == 'true' }}
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.commit_to_release }}

    - name: Install conda
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniconda-version: "latest"
        auto-update-conda: true
        activate-environment: alphax_release
        python-version: "${{ inputs.python_version }}"

    - name: Conda info
      shell: bash -el {0}
      run: |
        conda info

    - name: Get artifact name
      id: get_artifact
      shell: bash -el {0}
      run: |
        ARCH=$(python -c "import platform; arch=platform.machine().lower(); print('x64' if arch == 'x86_64' else arch)")
        KERNEL=$(python -c "import platform; print(platform.system().lower())")
        
        BUILD_NAME=${{ inputs.package_name }}-${{ needs.Get_New_Version.outputs.new_version }}-${KERNEL}-${ARCH}
        echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
        
        ARTIFACT_NAME=${BUILD_NAME}.deb
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
        echo got ARTIFACT_NAME=$ARTIFACT_NAME


    - name: Install pyinstaller 6.10.0 and build 1.2.1
      shell: bash -el {0}
      run: |
        pip install pyinstaller==6.10.0 build==1.2.1
        pip freeze

    - name: Build installer
      shell: bash -l {0}
      run: |
        release/linux/build_installer_linux.sh
        pip freeze
        ls *
        ls dist/*

    - name: Test app
      # TODO this is not unified yet between peptdeep & alphadia
      if: ${{ inputs.test_app }}
      shell: bash -el {0}
      run: |
        EXECUTABLE=dist/${{ inputs.package_name }}/${{ inputs.package_name }}
        COMMAND="--version"

        if [ ! -e ${EXECUTABLE} ]; then
          EXECUTABLE=dist/${{ inputs.package_name }}
          COMMAND="--help"
        fi
        
        echo calling ${EXECUTABLE} ${COMMAND}
        eval ${EXECUTABLE} ${COMMAND}


    # TODO: building node.js GUI not supported yet for linux

    - name: Build package
      id: build_package
      shell: bash -l {0}
      run: |
        release/linux/build_package_linux.sh
        ls *
        ls dist/*

    - name: Test package
      id: test_package
      shell: bash -l {0}
      run: |
        sudo dpkg -i dist/${{steps.get_artifact.outputs.ARTIFACT_NAME}}

    - name: Upload installer
      env:
        GH_TOKEN: ${{ github.token }}
        GH_REPO: ${{ github.repository }}
      run: gh release upload ${{ inputs.tag_to_release }} dist/${{steps.get_artifact.outputs.ARTIFACT_NAME}}

    # Fallback upload to be able to manually debug the artifact
    - name: Fallback upload installer as job asset
      if: ${{ failure() && steps.test_package.conclusion == 'failure' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{steps.get_artifact.outputs.ARTIFACT_NAME}}
        path: dist/${{steps.get_artifact.outputs.ARTIFACT_NAME}}
        if-no-files-found: error

  Create_MacOS_Installer:
    needs: [Create_Draft_Release, Get_New_Version]
    if: ${{ needs.Get_New_Version.outputs.run_macos == 'true' }}
    strategy:
      matrix:
        runner:
          - macos-latest-xlarge # this is ARM
          - macos-13 # this is not ARM
    runs-on: ${{matrix.runner}}
    env:
      EAGER_IMPORT: true  # TODO move to alphadia?
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.commit_to_release }}

    - name: Install conda
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniconda-version: "latest"
        auto-update-conda: true
        activate-environment: alphax_release
        python-version: "${{ inputs.python_version }}"

    - name: Conda info
      shell: bash -el {0}
      run: |
        conda info

    - name: Get artifact name
      id: get_artifact
      shell: bash -el {0}
      run: |
        ARCH=$(python -c "import platform; arch=platform.machine().lower(); print('x64' if arch == 'x86_64' else arch)")
        KERNEL=$(python -c "import platform; print(platform.system().lower())")
        
        BUILD_NAME=${{ inputs.package_name }}-${{ needs.Get_New_Version.outputs.new_version }}-macos-${KERNEL}-${ARCH}
        echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
        
        ARTIFACT_NAME=${BUILD_NAME}.pkg
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
        echo got ARTIFACT_NAME=$ARTIFACT_NAME

    - name: Install pyinstaller 6.10.0 and build 1.2.1
      shell: bash -el {0}
      run: |
        pip install pyinstaller==6.10.0 build==1.2.1
        pip freeze

    - name: Build installer
      shell: bash -el {0}
      run: |
        release/macos/build_installer_macos.sh
        pip freeze
        ls *
        ls dist/*

    - name: Test app
      if: ${{ inputs.test_app }}
      shell: bash -el {0}
      # TODO this is not unified yet between peptdeep & alphadia
      run: |
        EXECUTABLE=dist/${{ inputs.package_name }}/${{ inputs.package_name }}
        COMMAND="--version"
        
        if [ ! -e ${EXECUTABLE} ]; then
          EXECUTABLE=dist/${{ inputs.package_name }}_gui/${{ inputs.package_name }}_gui
          COMMAND="--help"
        fi

        echo calling ${EXECUTABLE} ${COMMAND}
        eval ${EXECUTABLE} ${COMMAND}

    # Build GUI
    - name: Setup Node.js
      if: ${{ inputs.build_nodejs_ui }}
      uses: actions/setup-node@v4

    - name: Build Node.js GUI
      if: ${{ inputs.build_nodejs_ui }}
      run: |
        release/macos/build_gui_macos.sh
        ls *

    - name: Build package
      continue-on-error: true
      id: build_package
      shell: bash -el {0}
      run: |
        release/macos/build_package_macos.sh
        ls *
        ls dist/*

    - name: Test package
      id: test_package
      shell: bash -l {0}
      run: |
        sudo installer -pkg dist/${{steps.get_artifact.outputs.ARTIFACT_NAME}} -target /

    - name: Upload installer
      env:
        GH_TOKEN: ${{ github.token }}
        GH_REPO: ${{ github.repository }}
      run: gh release upload ${{ inputs.tag_to_release }} dist/${{steps.get_artifact.outputs.ARTIFACT_NAME}}

    # Fallback upload to be able to manually debug the artifact
    - name: Fallback upload installer as job asset
      if: ${{ failure() && steps.test_package.conclusion == 'failure' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{steps.get_artifact.outputs.ARTIFACT_NAME}}
        path: dist/${{steps.get_artifact.outputs.ARTIFACT_NAME}}
        if-no-files-found: error

  Create_Windows_Installer:
    needs: [Create_Draft_Release, Get_New_Version]
    if: ${{ needs.Get_New_Version.outputs.run_windows == 'true' }}
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.commit_to_release }}

    - name: Install conda
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniconda-version: "latest"
        auto-update-conda: true
        activate-environment: alphax_release
        python-version: "${{ inputs.python_version }}"

    - name: Conda info
      shell: bash -el {0}
      run: |
        conda info
    
    - name: Get artifact name
      id: get_artifact
      shell: bash -el {0}
      run: |
        ARCH=$(python -c "import platform; arch=platform.machine().lower(); print('x64' if arch == 'x86_64' else arch)")
        KERNEL=$(python -c "import platform; print(platform.system().lower())")
        
        BUILD_NAME=${{ inputs.package_name }}-${{ needs.Get_New_Version.outputs.new_version }}-${KERNEL}-${ARCH}
        echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
        
        ARTIFACT_NAME=${BUILD_NAME}.exe
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
        echo got ARTIFACT_NAME=$ARTIFACT_NAME

    - name: Install pyinstaller 6.10.0 and build 1.2.1
      shell: bash -el {0}
      run: |
        pip install pefile==2023.2.7  # TODO: 2024.8.26 is super-slow on the 'binary vs. data reclassification' step, cf. https://github.com/erocarrera/pefile/issues/420
        pip install pyinstaller==6.10.0 build==1.2.1
        pip freeze

    - name: Build installer
      shell: powershell
      continue-on-error: true
      run: |
        release/windows/build_installer_windows.ps1
        pip freeze
        ls *
        ls dist/*

    - name: Test app
      if: ${{ inputs.test_app }}
      shell: bash -el {0}
      # TODO this is not unified yet between peptdeep & alphadia
      run: |
        EXECUTABLE=dist/${{ inputs.package_name }}/${{ inputs.package_name }}.exe
        COMMAND="--version"

        if [ ! -e ${EXECUTABLE} ]; then
          EXECUTABLE=dist/${{ inputs.package_name }}_gui/${{ inputs.package_name }}_gui.exe
          COMMAND="--help"
        fi

        echo calling ${EXECUTABLE} ${COMMAND}
        eval ${EXECUTABLE} ${COMMAND}

    # Build GUI
    - name: Setup Node.js
      if: ${{ inputs.build_nodejs_ui }}
      uses: actions/setup-node@v4

    - name: Build Node.js GUI
      if: ${{ inputs.build_nodejs_ui }}
      shell: powershell
      run: |
        release/windows/build_gui_windows.ps1

    - name: Build package
      id: build_package
      continue-on-error: true
      shell: powershell
      run: |
        release/windows/build_package_windows.ps1
        ls *
        ls dist/*

    - name: Get artifact location
      id: get_artifact_loc
      shell: bash -l {0}
      # TODO git rid of this step, this is not unified yet between peptdeep & alphadia
      run: |
        if [ -e release/windows/dist/${{steps.get_artifact.outputs.ARTIFACT_NAME}} ]; then
            ARTIFACT_LOC=release/windows/dist
        else
            ARTIFACT_LOC=dist
        fi
        echo got ARTIFACT_LOC=$ARTIFACT_LOC
        echo "ARTIFACT_LOC=$ARTIFACT_LOC" >> $GITHUB_OUTPUT

    - name: Test package
      id: test_package
      shell: bash -l {0}
      run: |
        ${{steps.get_artifact_loc.outputs.ARTIFACT_LOC}}/${{steps.get_artifact.outputs.ARTIFACT_NAME}} //verysilent //SUPPRESSMSGBOXES //log=log.txt //noicons //tasks= //portable=1
        cat log.txt

    - name: Upload installer
      env:
        GH_TOKEN: ${{ github.token }}
        GH_REPO: ${{ github.repository }}
      run: gh release upload "${{ inputs.tag_to_release }}" ${{steps.get_artifact_loc.outputs.ARTIFACT_LOC}}/${{steps.get_artifact.outputs.ARTIFACT_NAME}}

    # Fallback upload to be able to manually debug the artifact
    - name: Fallback upload installer as job asset
      if: ${{ failure() && steps.test_package.conclusion == 'failure' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{steps.get_artifact.outputs.ARTIFACT_NAME}}
        path: ${{steps.get_artifact_loc.outputs.ARTIFACT_LOC}}/${{steps.get_artifact.outputs.ARTIFACT_NAME}}
        if-no-files-found: error